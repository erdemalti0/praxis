{
  "content": "import { Terminal } from \"@xterm/xterm\";\nimport { FitAddon } from \"@xterm/addon-fit\";\nimport { WebglAddon } from \"@xterm/addon-webgl\";\nimport { SearchAddon } from \"@xterm/addon-search\";\n\ninterface CachedTerminal {\n  terminal: Terminal;\n  fitAddon: FitAddon;\n  searchAddon: SearchAddon;\n}\n\nconst cache = new Map<string, CachedTerminal>();\n\nconst TERMINAL_THEME = {\n  background: \"#000000\",\n  foreground: \"#e0e0e0\",\n  cursor: \"#ffffff\",\n  cursorAccent: \"#000000\",\n  selectionBackground: \"#333333\",\n  black: \"#333333\",\n  red: \"#f87171\",\n  green: \"#4ade80\",\n  yellow: \"#facc15\",\n  blue: \"#a0a0a0\",\n  magenta: \"#a78bfa\",\n  cyan: \"#67e8f9\",\n  white: \"#d4d4d4\",\n  brightBlack: \"#525252\",\n  brightRed: \"#fca5a5\",\n  brightGreen: \"#86efac\",\n  brightYellow: \"#fde68a\",\n  brightBlue: \"#d4d4d4\",\n  brightMagenta: \"#c4b5fd\",\n  brightCyan: \"#a5f3fc\",\n  brightWhite: \"#ffffff\",\n};\n\nexport function getOrCreateTerminal(sessionId: string): CachedTerminal {\n  const existing = cache.get(sessionId);\n  if (existing) return existing;\n\n  const terminal = new Terminal({\n    fontFamily: \"'JetBrains Mono', 'SF Mono', Monaco, Menlo, monospace\",\n    fontSize: 13,\n    lineHeight: 1.4,\n    theme: TERMINAL_THEME,\n    cursorBlink: false,\n    allowProposedApi: true,\n    scrollback: 2000,\n    fastScrollModifier: \"alt\",\n    fastScrollSensitivity: 5,\n  });\n\n  const fitAddon = new FitAddon();\n  terminal.loadAddon(fitAddon);\n\n  const searchAddon = new SearchAddon();\n  terminal.loadAddon(searchAddon);\n\n  const entry: CachedTerminal = { terminal, fitAddon, searchAddon };\n  cache.set(sessionId, entry);\n  return entry;\n}\n\n/**\n * Activate WebGL renderer after terminal is mounted to DOM.\n * Falls back silently to canvas/DOM if WebGL is unavailable.\n */\nexport function activateWebGL(sessionId: string): void {\n  const entry = cache.get(sessionId);\n  if (!entry) return;\n  // Only attach once\n  if ((entry.terminal as any).__webgl) return;\n  try {\n    const webgl = new WebglAddon();\n    webgl.onContextLoss(() => {\n      webgl.dispose();\n      (entry.terminal as any).__webgl = false;\n    });\n    entry.terminal.loadAddon(webgl);\n    (entry.terminal as any).__webgl = true;\n  } catch {\n    // WebGL not available â€” canvas/DOM renderer used automatically\n  }\n}\n\nexport function getCachedTerminal(sessionId: string): CachedTerminal | undefined {\n  return cache.get(sessionId);\n}\n\n/**\n * Full cleanup: run PTY listener cleanup, dispose xterm, remove from cache.\n */\nexport function cleanupTerminal(sessionId: string): void {\n  const entry = cache.get(sessionId);\n  if (entry) {\n    const ptyKey = `__pty_${sessionId}`;\n    const cleanupFn = (entry.terminal as any)[`${ptyKey}_cleanup`];\n    if (typeof cleanupFn === \"function\") {\n      cleanupFn();\n    }\n    entry.terminal.dispose();\n    cache.delete(sessionId);\n  }\n}\n\nexport function disposeTerminal(sessionId: string): void {\n  cleanupTerminal(sessionId);\n}\n\nexport function hasCachedTerminal(sessionId: string): boolean {\n  return cache.has(sessionId);\n}\n\n/**\n * Re-fit all cached terminals that are currently mounted in the DOM.\n * Used after layout changes (fullscreen toggle, sidebar toggle, etc.)\n * to prevent terminals from going black.\n */\nexport function refitAllTerminals(): void {\n  // Delay to allow layout to settle\n  requestAnimationFrame(() => {\n    setTimeout(() => {\n      for (const [, entry] of cache) {\n        try {\n          if (entry.terminal.element) {\n            entry.fitAddon.fit();\n          }\n        } catch {}\n      }\n    }, 100);\n  });\n}\n",
  "hash": "e64a0c8cc4f973d464d9330c0e8a02bd",
  "tokenCount": 789,
  "timestamp": "2026-02-15T13:19:02.508Z"
}