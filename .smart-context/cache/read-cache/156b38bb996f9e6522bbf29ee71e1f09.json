{
  "content": "import { create } from \"zustand\";\n\nexport interface TerminalSession {\n  id: string;\n  title: string;\n  workspaceId: string;\n  agentType?: string;\n  projectPath?: string;\n  pid?: number;\n  isActive: boolean;\n}\n\nexport interface OutputActivity {\n  lastOutputAt: number;\n  recentBytes: number;       // bytes in current window\n  lastUserInputAt: number;\n  windowStart: number;       // when current measurement window started\n}\n\n/** Check if a session is actively working based on output activity */\nexport function isSessionWorking(activity: OutputActivity | undefined): boolean {\n  if (!activity) return false;\n  const now = Date.now();\n  const timeSinceOutput = now - activity.lastOutputAt;\n\n  // No output in last 5s → not working\n  if (timeSinceOutput > 5000) return false;\n\n  // If user just typed (within 1s) and output is very small, it's likely echo\n  const timeSinceInput = now - activity.lastUserInputAt;\n  if (timeSinceInput < 1000 && activity.recentBytes < 30) return false;\n\n  // Any output within last 5s → working (agents produce varied output sizes including small spinner updates)\n  return true;\n}\n\ninterface TerminalState {\n  sessions: TerminalSession[];\n  activeSessionId: string | null;\n  /** Timestamp (ms) of last PTY output per session — kept for backward compat */\n  lastOutputAt: Record<string, number>;\n  /** Detailed output activity tracking per session */\n  outputActivity: Record<string, OutputActivity>;\n  addSession: (session: TerminalSession) => void;\n  removeSession: (id: string) => void;\n  setActiveSession: (id: string) => void;\n  updateSession: (id: string, updates: Partial<TerminalSession>) => void;\n  getSessionsByWorkspace: (workspaceId: string) => TerminalSession[];\n  markOutput: (id: string, byteCount?: number) => void;\n  markUserInput: (id: string) => void;\n  resetOutputWindow: (id: string) => void;\n}\n\nexport const useTerminalStore = create<TerminalState>((set, get) => ({\n  sessions: [],\n  activeSessionId: null,\n  lastOutputAt: {},\n  outputActivity: {},\n\n  addSession: (session) =>\n    set((state) => ({\n      sessions: [...state.sessions, session],\n      activeSessionId: session.id,\n    })),\n\n  removeSession: (id) =>\n    set((state) => {\n      const removed = state.sessions.find((s) => s.id === id);\n      const sessions = state.sessions.filter((s) => s.id !== id);\n      let nextActive = state.activeSessionId;\n      if (state.activeSessionId === id) {\n        const sameWs = removed\n          ? sessions.filter((s) => s.workspaceId === removed.workspaceId)\n          : sessions;\n        nextActive = sameWs[sameWs.length - 1]?.id ?? sessions[sessions.length - 1]?.id ?? null;\n      }\n      const { [id]: _, ...restOutput } = state.lastOutputAt;\n      const { [id]: _2, ...restActivity } = state.outputActivity;\n      return { sessions, activeSessionId: nextActive, lastOutputAt: restOutput, outputActivity: restActivity };\n    }),\n\n  setActiveSession: (id) => set({ activeSessionId: id }),\n\n  updateSession: (id, updates) =>\n    set((state) => ({\n      sessions: state.sessions.map((s) =>\n        s.id === id ? { ...s, ...updates } : s\n      ),\n    })),\n\n  getSessionsByWorkspace: (workspaceId) =>\n    get().sessions.filter((s) => s.workspaceId === workspaceId),\n\n  markOutput: (id, byteCount = 0) =>\n    set((state) => {\n      const now = Date.now();\n      const prev = state.outputActivity[id];\n      const windowStart = prev?.windowStart || now;\n      // Reset window every 5 seconds\n      const windowExpired = now - windowStart > 5000;\n      const activity: OutputActivity = {\n        lastOutputAt: now,\n        recentBytes: windowExpired ? byteCount : (prev?.recentBytes || 0) + byteCount,\n        lastUserInputAt: prev?.lastUserInputAt || 0,\n        windowStart: windowExpired ? now : windowStart,\n      };\n      return {\n        lastOutputAt: { ...state.lastOutputAt, [id]: now },\n        outputActivity: { ...state.outputActivity, [id]: activity },\n      };\n    }),\n\n  markUserInput: (id) =>\n    set((state) => {\n      const prev = state.outputActivity[id];\n      if (!prev) return state;\n      return {\n        outputActivity: {\n          ...state.outputActivity,\n          [id]: { ...prev, lastUserInputAt: Date.now() },\n        },\n      };\n    }),\n\n  resetOutputWindow: (id) =>\n    set((state) => {\n      const prev = state.outputActivity[id];\n      if (!prev) return state;\n      return {\n        outputActivity: {\n          ...state.outputActivity,\n          [id]: { ...prev, recentBytes: 0, windowStart: Date.now() },\n        },\n      };\n    }),\n}));\n",
  "hash": "156b38bb996f9e6522bbf29ee71e1f09",
  "tokenCount": 1001,
  "timestamp": "2026-02-15T13:19:05.746Z"
}