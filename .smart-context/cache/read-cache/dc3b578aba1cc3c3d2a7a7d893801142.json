{
  "content": "import type { IPty } from \"node-pty\";\nimport os from \"os\";\nimport path from \"path\";\nimport { randomUUID } from \"crypto\";\nimport { getUserShellEnv } from \"./shell-env\";\n\ninterface PtySession {\n  pty: IPty;\n  cols: number;\n  rows: number;\n}\n\nconst sessions = new Map<string, PtySession>();\n\nfunction expandHome(cwd: string): string {\n  if (cwd.startsWith(\"~\")) {\n    return cwd.replace(\"~\", os.homedir());\n  }\n  return cwd;\n}\n\nexport function spawnPty(\n  id: string,\n  cmd: string,\n  args: string[],\n  cwd: string,\n  cols: number,\n  rows: number,\n  onData: (id: string, data: string) => void,\n  onExit?: (id: string, exitCode: number, signal?: number) => void\n): { id: string; cwd: string } {\n  // Dynamic require for node-pty (native module)\n  const pty = require(\"node-pty\");\n\n  const expandedCwd = expandHome(cwd);\n\n  // Resolve to absolute path\n  const resolvedCwd = path.resolve(expandedCwd);\n\n  // Validate cwd exists, fallback to home directory\n  const fs = require(\"fs\");\n  let safeCwd = resolvedCwd;\n  try {\n    if (!fs.existsSync(safeCwd) || !fs.statSync(safeCwd).isDirectory()) {\n      safeCwd = os.homedir();\n    }\n  } catch {\n    safeCwd = os.homedir();\n  }\n\n  const isWindows = process.platform === \"win32\";\n\n  // Use the user's full shell environment so agent CLIs (claude, aider, etc.)\n  // are found in PATH even in packaged builds\n  const userEnv = getUserShellEnv();\n\n  const shell = pty.spawn(cmd, args, {\n    name: isWindows ? undefined : \"xterm-256color\",\n    cols: cols || 80,\n    rows: rows || 24,\n    cwd: safeCwd,\n    env: {\n      ...userEnv,\n      ...(isWindows ? {} : { TERM: \"xterm-256color\" }),\n      PWD: safeCwd,\n      HOME: os.homedir(),\n    },\n  });\n\n  sessions.set(id, { pty: shell, cols: cols || 80, rows: rows || 24 });\n\n  shell.onData((data: string) => {\n    onData(id, data);\n  });\n\n  shell.onExit(({ exitCode, signal }: { exitCode: number; signal?: number }) => {\n    sessions.delete(id);\n    onExit?.(id, exitCode, signal);\n  });\n\n  return { id, cwd: safeCwd };\n}\n\nexport function writePty(id: string, data: string): void {\n  const session = sessions.get(id);\n  if (!session) throw new Error(`Session ${id} not found`);\n  session.pty.write(data);\n}\n\nexport function resizePty(id: string, cols: number, rows: number): void {\n  const session = sessions.get(id);\n  if (!session) return;\n  session.pty.resize(cols, rows);\n  session.cols = cols;\n  session.rows = rows;\n}\n\nexport function closePty(id: string): void {\n  const session = sessions.get(id);\n  if (session) {\n    session.pty.kill();\n    sessions.delete(id);\n  }\n}\n\n/** Kill all active PTY sessions — called on app quit. */\nexport function closeAllPty(): void {\n  for (const [id, session] of sessions) {\n    try {\n      session.pty.kill();\n    } catch {\n      // ignore — process may already be dead\n    }\n  }\n  sessions.clear();\n}\n",
  "hash": "dc3b578aba1cc3c3d2a7a7d893801142",
  "tokenCount": 631,
  "timestamp": "2026-02-15T13:19:03.408Z"
}