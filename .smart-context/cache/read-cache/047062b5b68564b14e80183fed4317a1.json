{
  "content": "import { useEffect, useRef, useState, useCallback } from \"react\";\nimport { Columns2, Rows2, Plus, Hand } from \"lucide-react\";\nimport { useTerminalStore } from \"../../stores/terminalStore\";\nimport { useUIStore } from \"../../stores/uiStore\";\nimport { invoke, listen } from \"../../lib/ipc\";\nimport { getOrCreateTerminal, activateWebGL } from \"../../lib/terminal/terminalCache\";\nimport { getDefaultShell } from \"../../lib/platform\";\nimport { swapPanes } from \"../../lib/layout/layoutUtils\";\nimport \"@xterm/xterm/css/xterm.css\";\n\n/** Bracket paste escape sequences — wraps pasted text so TUI apps treat it as paste */\nconst BRACKET_PASTE_START = \"\\x1b[200~\";\nconst BRACKET_PASTE_END = \"\\x1b[201~\";\n\n/** Save image File to temp, return path */\nasync function saveImageToTemp(file: File): Promise<string> {\n  const ext = file.type === \"image/jpeg\" ? \"jpg\" : \"png\";\n  const arrayBuf = await file.arrayBuffer();\n  const bytes = new Uint8Array(arrayBuf);\n  // Convert in 8KB chunks instead of byte-by-byte for performance\n  const chunks: string[] = [];\n  for (let i = 0; i < bytes.length; i += 8192) {\n    chunks.push(String.fromCharCode(...bytes.subarray(i, Math.min(i + 8192, bytes.length))));\n  }\n  const base64 = btoa(chunks.join(\"\"));\n  const tmpDir = (window as any).electronAPI.getTempDir();\n  const filePath = `${tmpDir}/praxis-drop-${Date.now()}.${ext}`;\n  (window as any).electronAPI.writeFileBinary(filePath, base64);\n  return filePath;\n}\n\n/** Write text to PTY using bracket paste mode */\nfunction pasteToTerminal(sessionId: string, text: string) {\n  invoke(\"write_pty\", { id: sessionId, data: BRACKET_PASTE_START + text + BRACKET_PASTE_END }).catch(() => {});\n}\n\ninterface TerminalPaneProps {\n  sessionId: string | null;\n  isFocused: boolean;\n}\n\nexport default function TerminalPane({ sessionId, isFocused }: TerminalPaneProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const terminalRef = useRef<ReturnType<typeof getOrCreateTerminal> | null>(null);\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\n  const [hovered, setHovered] = useState(false);\n  const [dragOver, setDragOver] = useState(false);\n  const [fileDragOver, setFileDragOver] = useState(false);\n\n  const setActiveSession = useTerminalStore((s) => s.setActiveSession);\n  const setFocusedPane = useUIStore((s) => s.setFocusedPane);\n  const setSplitSpawnContext = useUIStore((s) => s.setSplitSpawnContext);\n  const setShowSpawnDialog = useUIStore((s) => s.setShowSpawnDialog);\n  const draggingPaneSessionId = useUIStore((s) => s.draggingPaneSessionId);\n  const setDraggingPaneSessionId = useUIStore((s) => s.setDraggingPaneSessionId);\n\n  const someoneIsDragging = draggingPaneSessionId !== null;\n  const isDragging = draggingPaneSessionId === sessionId;\n\n  const handleFocus = () => {\n    if (sessionId) {\n      setFocusedPane(sessionId);\n      setActiveSession(sessionId);\n    }\n  };\n\n  const handleSplit = (direction: \"horizontal\" | \"vertical\") => {\n    if (sessionId) {\n      setSplitSpawnContext({ sessionId, direction });\n      setShowSpawnDialog(true);\n    }\n  };\n\n  const handleDragStart = useCallback(\n    (e: React.DragEvent) => {\n      if (!sessionId) return;\n      e.dataTransfer.setData(\"text/plain\", sessionId);\n      e.dataTransfer.effectAllowed = \"move\";\n      setTimeout(() => setDraggingPaneSessionId(sessionId), 0);\n    },\n    [sessionId, setDraggingPaneSessionId]\n  );\n\n  const handleDragEnd = useCallback(() => {\n    setDraggingPaneSessionId(null);\n    setDragOver(false);\n  }, [setDraggingPaneSessionId]);\n\n  const handleDragOver = useCallback(\n    (e: React.DragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (draggingPaneSessionId && draggingPaneSessionId !== sessionId) {\n        e.dataTransfer.dropEffect = \"move\";\n        setDragOver(true);\n      }\n    },\n    [draggingPaneSessionId, sessionId]\n  );\n\n  const handleDragLeave = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragOver(false);\n  }, []);\n\n  const handleDrop = useCallback(\n    (e: React.DragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setDragOver(false);\n\n      // Internal pane swap only — file drops are handled by DropOverlay\n      const draggedId = e.dataTransfer.getData(\"text/plain\");\n      if (!draggedId || !sessionId || draggedId === sessionId) return;\n\n      const ui = useUIStore.getState();\n      const wsId = ui.activeWorkspaceId;\n      if (!wsId) return;\n      const groups = ui.terminalGroups[wsId] || [];\n      const activeGroupId = ui.activeTerminalGroup[wsId] || groups[0];\n      if (!activeGroupId) return;\n\n      const layout = ui.workspaceLayouts[activeGroupId];\n      if (!layout) return;\n\n      const newLayout = swapPanes(layout, draggedId, sessionId);\n      ui.setWorkspaceLayout(activeGroupId, newLayout);\n      setDraggingPaneSessionId(null);\n    },\n    [sessionId, setDraggingPaneSessionId]\n  );\n\n  // ── File drag detection: only on THIS pane via native listeners on outer div ──\n  const outerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const el = outerRef.current;\n    if (!el || !sessionId) return;\n\n    let enterCount = 0;\n\n    const onDragEnter = (e: DragEvent) => {\n      if (draggingPaneSessionId) return;\n      const types = e.dataTransfer?.types || [];\n      if (types.includes(\"Files\") || types.includes(\"public.file-url\")) {\n        enterCount++;\n        setFileDragOver(true);\n      }\n    };\n\n    const onDragLeave = () => {\n      enterCount--;\n      if (enterCount <= 0) {\n        enterCount = 0;\n        setFileDragOver(false);\n      }\n    };\n\n    const onDrop = () => {\n      enterCount = 0;\n      setFileDragOver(false);\n    };\n\n    el.addEventListener(\"dragenter\", onDragEnter);\n    el.addEventListener(\"dragleave\", onDragLeave);\n    el.addEventListener(\"drop\", onDrop);\n    return () => {\n      el.removeEventListener(\"dragenter\", onDragEnter);\n      el.removeEventListener(\"dragleave\", onDragLeave);\n      el.removeEventListener(\"drop\", onDrop);\n    };\n  }, [sessionId, draggingPaneSessionId]);\n\n  // Re-fit terminal when focus changes (switching between terminals)\n  useEffect(() => {\n    if (isFocused && terminalRef.current) {\n      requestAnimationFrame(() => {\n        try { terminalRef.current?.fitAddon.fit(); } catch {}\n      });\n    }\n  }, [isFocused]);\n\n  // Main terminal setup effect\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container || !sessionId) {\n      return;\n    }\n\n    // Get or create terminal instance from shared cache\n    const { terminal, fitAddon, searchAddon } = getOrCreateTerminal(sessionId);\n    terminalRef.current = { terminal, fitAddon, searchAddon };\n\n    // Mount terminal to DOM\n    if (!terminal.element) {\n      terminal.open(container);\n    } else if (!container.contains(terminal.element)) {\n      container.innerHTML = \"\";\n      container.appendChild(terminal.element);\n    }\n\n    // Fit terminal + activate WebGL after mount\n    requestAnimationFrame(() => {\n      try {\n        fitAddon.fit();\n      } catch {}\n      activateWebGL(sessionId);\n    });\n\n    // Set up PTY connection if not already connected\n    const ptyKey = `__pty_${sessionId}`;\n    if (!(terminal as any)[ptyKey]) {\n      (terminal as any)[ptyKey] = true;\n\n      // Single PTY output listener: write to xterm + track activity\n      let lastMark = 0;\n      let pendingBytes = 0;\n      let flushTimer: ReturnType<typeof setTimeout> | null = null;\n      const flushOutput = () => {\n        if (pendingBytes > 0) {\n          useTerminalStore.getState().markOutput(sessionId!, pendingBytes);\n          pendingBytes = 0;\n          lastMark = Date.now();\n        }\n      };\n      const unsubOutput = listen(`pty-output-${sessionId}`, (data: string) => {\n        terminal.write(data);\n        pendingBytes += (typeof data === \"string\" ? data.length : 0);\n        const now = Date.now();\n        if (now - lastMark > 200) {\n          flushOutput();\n        } else {\n          // Schedule trailing flush to capture the last batch\n          if (flushTimer) clearTimeout(flushTimer);\n          flushTimer = setTimeout(flushOutput, 250);\n        }\n      });\n\n      const unsubExit = listen(`pty-exit-${sessionId}`, (info?: { exitCode: number; signal?: number }) => {\n        const store = useTerminalStore.getState();\n        const session = store.sessions.find((s) => s.id === sessionId);\n        const isShell = session?.agentType === \"shell\";\n\n        if (!isShell) {\n          const shellCwd = session?.projectPath || \"~\";\n          terminal.write(\"\\r\\n\\x1b[90m[Process exited — starting shell...]\\x1b[0m\\r\\n\\r\\n\");\n          getDefaultShell().then((defaultShell) => invoke<{ id: string; cwd: string }>(\"spawn_pty\", {\n            id: sessionId,\n            cmd: defaultShell,\n            args: [],\n            cwd: shellCwd,\n          })).then((res) => {\n            const actualCwd = res?.cwd || shellCwd;\n            store.updateSession(sessionId!, {\n              agentType: \"shell\",\n              title: `Shell@${actualCwd.split(\"/\").pop() || actualCwd}`,\n              projectPath: actualCwd,\n            });\n          }).catch(() => {\n            terminal.write(\"\\x1b[91m[Failed to start shell]\\x1b[0m\\r\\n\");\n          });\n        } else {\n          const code = info?.exitCode ?? -1;\n          const sig = info?.signal;\n          const details = sig ? `signal=${sig}` : `code=${code}`;\n          terminal.write(`\\r\\n\\x1b[90m[Shell exited: ${details}]\\x1b[0m\\r\\n`);\n        }\n      });\n\n      const dataDisposable = terminal.onData((data) => {\n        invoke(\"write_pty\", { id: sessionId, data }).catch(() => {});\n        useTerminalStore.getState().markUserInput(sessionId!);\n      });\n\n      const resizeDisposable = terminal.onResize(({ cols, rows }) => {\n        invoke(\"resize_pty\", { id: sessionId, cols, rows }).catch(() => {});\n      });\n\n      invoke(\"resize_pty\", {\n        id: sessionId,\n        cols: terminal.cols,\n        rows: terminal.rows\n      }).catch(() => {});\n\n      (terminal as any)[`${ptyKey}_cleanup`] = () => {\n        unsubOutput();\n        unsubExit();\n        dataDisposable.dispose();\n        resizeDisposable.dispose();\n        delete (terminal as any)[ptyKey];\n        delete (terminal as any)[`${ptyKey}_cleanup`];\n      };\n    }\n\n    // Handle image paste on xterm's internal textarea\n    const xtermTextarea = terminal.element?.querySelector(\"textarea\");\n    const pasteHandler = async (e: ClipboardEvent) => {\n      const hasImage = e.clipboardData?.items\n        ? Array.from(e.clipboardData.items).some((i) => i.type.startsWith(\"image/\"))\n        : false;\n\n      if (hasImage) {\n        e.preventDefault();\n        e.stopPropagation();\n        const items = e.clipboardData?.items;\n        if (!items) return;\n        for (const item of Array.from(items)) {\n          if (item.type.startsWith(\"image/\")) {\n            const blob = item.getAsFile();\n            if (!blob) continue;\n            const filePath = await saveImageToTemp(blob);\n            pasteToTerminal(sessionId, filePath);\n            return;\n          }\n        }\n      }\n    };\n\n    if (xtermTextarea) {\n      xtermTextarea.addEventListener(\"paste\", pasteHandler as EventListener);\n    }\n\n    // Resize observer\n    let resizeTimer: ReturnType<typeof setTimeout> | null = null;\n    resizeObserverRef.current = new ResizeObserver(() => {\n      if (resizeTimer) clearTimeout(resizeTimer);\n      resizeTimer = setTimeout(() => {\n        try { fitAddon.fit(); } catch {}\n      }, 50);\n    });\n    resizeObserverRef.current.observe(container);\n\n    return () => {\n      resizeObserverRef.current?.disconnect();\n      if (resizeTimer) clearTimeout(resizeTimer);\n      if (xtermTextarea) {\n        xtermTextarea.removeEventListener(\"paste\", pasteHandler as EventListener);\n      }\n    };\n  }, [sessionId]);\n\n  if (!sessionId) {\n    return (\n      <div\n        className=\"w-full h-full flex items-center justify-center\"\n        style={{\n          background: \"var(--vp-bg-primary)\",\n          border: dragOver ? \"2px solid var(--vp-accent-blue-glow)\" : \"1px solid var(--vp-border-subtle)\",\n        }}\n        onDragOver={handleDragOver}\n        onDragLeave={handleDragLeave}\n      >\n        <div style={{\n          display: \"flex\", flexDirection: \"column\", alignItems: \"center\", justifyContent: \"center\",\n          height: \"100%\", gap: 16, color: \"var(--vp-text-faint)\"\n        }}>\n          <button\n            onClick={() => setShowSpawnDialog(true)}\n            className=\"flex items-center gap-2 px-4 py-2 text-xs\"\n            style={{\n              color: \"var(--vp-text-muted)\",\n              border: \"1px solid var(--vp-border-light)\",\n              borderRadius: 8,\n              background: \"var(--vp-bg-surface)\",\n              cursor: \"pointer\",\n              transition: \"all 0.2s\",\n            }}\n            onMouseEnter={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-primary)\";\n              e.currentTarget.style.borderColor = \"var(--vp-border-strong)\";\n            }}\n            onMouseLeave={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-muted)\";\n              e.currentTarget.style.borderColor = \"var(--vp-border-light)\";\n            }}\n          >\n            <Plus size={14} />\n            New Terminal\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  let borderColor = \"var(--vp-border-subtle)\";\n  if (dragOver) {\n    borderColor = \"var(--vp-accent-blue-glow)\";\n  } else if (isFocused) {\n    borderColor = \"var(--vp-accent-blue-glow)\";\n  }\n\n  return (\n    <div\n      ref={outerRef}\n      className=\"relative w-full h-full\"\n      style={{\n        border: `2px solid ${borderColor}`,\n        transition: \"border-color 0.15s, opacity 0.15s\",\n        opacity: isDragging ? 0.4 : 1,\n        overflow: \"hidden\",\n      }}\n      onClick={handleFocus}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      onMouseEnter={() => setHovered(true)}\n      onMouseLeave={() => { if (!someoneIsDragging) setHovered(false); }}\n    >\n      {/* Internal pane swap overlay */}\n      {dragOver && (\n        <div\n          className=\"absolute inset-0 z-10\"\n          style={{\n            background: \"var(--vp-accent-blue-bg)\",\n            border: \"2px dashed var(--vp-accent-blue-glow)\",\n            borderRadius: 2,\n            pointerEvents: \"none\",\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n          }}\n        >\n          <span style={{ color: \"var(--vp-accent-blue-glow)\", fontSize: 12, fontWeight: 500 }}>\n            Drop to swap\n          </span>\n        </div>\n      )}\n\n      {/* File/image drop overlay — only on THIS terminal when files dragged over it */}\n      {fileDragOver && !dragOver && (\n        <DropOverlay\n          sessionId={sessionId}\n          onDone={() => setFileDragOver(false)}\n        />\n      )}\n\n      {hovered && !someoneIsDragging && (\n        <div\n          className=\"absolute top-1 right-1 flex gap-1 z-10\"\n          style={{ animation: \"fadeIn 0.15s ease\" }}\n        >\n          <div\n            draggable\n            onDragStart={handleDragStart}\n            onDragEnd={handleDragEnd}\n            title=\"Drag to swap\"\n            className=\"flex items-center justify-center\"\n            style={{\n              width: 24,\n              height: 24,\n              borderRadius: 6,\n              background: \"var(--vp-bg-overlay)\",\n              border: \"1px solid var(--vp-border-medium)\",\n              color: \"var(--vp-text-secondary)\",\n              cursor: \"grab\",\n              transition: \"all 0.15s\",\n            }}\n            onMouseEnter={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-primary)\";\n              e.currentTarget.style.background = \"var(--vp-border-medium)\";\n            }}\n            onMouseLeave={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-secondary)\";\n              e.currentTarget.style.background = \"var(--vp-bg-overlay)\";\n            }}\n          >\n            <Hand size={12} />\n          </div>\n          <button\n            onClick={(e) => { e.stopPropagation(); handleSplit(\"horizontal\"); }}\n            title=\"Split Right\"\n            className=\"flex items-center justify-center\"\n            style={{\n              width: 24,\n              height: 24,\n              borderRadius: 6,\n              background: \"var(--vp-bg-overlay)\",\n              border: \"1px solid var(--vp-border-medium)\",\n              color: \"var(--vp-text-secondary)\",\n              cursor: \"pointer\",\n              transition: \"all 0.15s\",\n            }}\n            onMouseEnter={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-primary)\";\n              e.currentTarget.style.background = \"var(--vp-accent-blue-border)\";\n            }}\n            onMouseLeave={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-secondary)\";\n              e.currentTarget.style.background = \"var(--vp-bg-overlay)\";\n            }}\n          >\n            <Columns2 size={12} />\n          </button>\n          <button\n            onClick={(e) => { e.stopPropagation(); handleSplit(\"vertical\"); }}\n            title=\"Split Down\"\n            className=\"flex items-center justify-center\"\n            style={{\n              width: 24,\n              height: 24,\n              borderRadius: 6,\n              background: \"var(--vp-bg-overlay)\",\n              border: \"1px solid var(--vp-border-medium)\",\n              color: \"var(--vp-text-secondary)\",\n              cursor: \"pointer\",\n              transition: \"all 0.15s\",\n            }}\n            onMouseEnter={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-primary)\";\n              e.currentTarget.style.background = \"var(--vp-accent-blue-border)\";\n            }}\n            onMouseLeave={(e) => {\n              e.currentTarget.style.color = \"var(--vp-text-secondary)\";\n              e.currentTarget.style.background = \"var(--vp-bg-overlay)\";\n            }}\n          >\n            <Rows2 size={12} />\n          </button>\n        </div>\n      )}\n\n      <div\n        ref={containerRef}\n        className=\"w-full h-full\"\n        style={{ background: \"var(--vp-bg-primary)\", minHeight: 80, overflow: \"hidden\" }}\n      />\n    </div>\n  );\n}\n\n/**\n * Transparent overlay that captures file/image drops via native DOM events.\n * Mounts on top of xterm canvas only on the terminal being dragged over.\n */\n/**\n * Transparent overlay that captures file/image drops via native DOM events.\n * Mounts on top of xterm canvas only on the terminal being dragged over.\n */\nfunction DropOverlay({ sessionId, onDone }: { sessionId: string | null; onDone: () => void }) {\n  const ref = useRef<HTMLDivElement>(null);\n  const onDoneRef = useRef(onDone);\n  onDoneRef.current = onDone;\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) return;\n\n    const onDragOver = (e: DragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.dataTransfer) e.dataTransfer.dropEffect = \"copy\";\n    };\n\n    const onDrop = async (e: DragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const dt = e.dataTransfer;\n      if (!sessionId || !dt) {\n        onDoneRef.current();\n        return;\n      }\n\n      // Find image or file\n      let imageFile: File | null = null;\n      let filePath: string | null = null;\n\n      if (dt.files && dt.files.length > 0) {\n        const f = dt.files[0];\n        if (f.type.startsWith(\"image/\")) imageFile = f;\n        else filePath = (f as any).path || null;\n      }\n\n      if (!imageFile && !filePath && dt.items) {\n        for (const item of Array.from(dt.items)) {\n          if (item.kind === \"file\") {\n            const f = item.getAsFile();\n            if (!f) continue;\n            if (f.type.startsWith(\"image/\")) { imageFile = f; break; }\n            filePath = (f as any).path || null;\n            if (filePath) break;\n          }\n        }\n      }\n\n      if (imageFile) {\n        try {\n          const savedPath = await saveImageToTemp(imageFile);\n          pasteToTerminal(sessionId, savedPath);\n        } catch (err) {\n          console.error(\"[DropOverlay] save failed:\", err);\n        }\n      } else if (filePath) {\n        pasteToTerminal(sessionId, filePath);\n      }\n\n      onDoneRef.current();\n    };\n\n    el.addEventListener(\"dragover\", onDragOver);\n    el.addEventListener(\"drop\", onDrop);\n    return () => {\n      el.removeEventListener(\"dragover\", onDragOver);\n      el.removeEventListener(\"drop\", onDrop);\n    };\n  }, [sessionId]);\n\n  // Safety: auto-hide after 6 seconds\n  useEffect(() => {\n    const timer = setTimeout(() => onDoneRef.current(), 6000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div\n      ref={ref}\n      style={{\n        position: \"absolute\",\n        inset: 0,\n        zIndex: 20,\n        background: \"rgba(74, 222, 128, 0.08)\",\n        border: \"2px dashed var(--vp-accent-green)\",\n        borderRadius: 2,\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        cursor: \"copy\",\n      }}\n    >\n      <span style={{ color: \"var(--vp-accent-green)\", fontSize: 12, fontWeight: 500, pointerEvents: \"none\" }}>\n        Drop image / file\n      </span>\n    </div>\n  );\n}\n",
  "hash": "047062b5b68564b14e80183fed4317a1",
  "tokenCount": 4569,
  "timestamp": "2026-02-15T13:19:02.078Z"
}